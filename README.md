# casper.js を作った、または Cache Aware Server Push を用いた HTTP/2 Push の効率化

分かってる人にとっては、「casper.js を作った」だけで伝わるかもしれませんが、そうでない場合非常に話すべきことがたくさん有る気がするので、順を追って説明します。

今回理解すべき内容は以下


- http2 push の問題点
- cache aware server push
- bloom filter と golomb coded set
- cache fingerprinting
- casper.js


# http2 push の問題点

http2 で push することで、リソースをブラウザにキャッシュしてキャッシュヒットさせる、というユースケースについてはもう散々語られたと思うので、それは前提とします。

問題は、例えば index.html へのリクエストで script.js を push する設定をした場合に、サーバは毎回 script.js を push しては無駄なわけです。
もしすでに push 済みであれば、 push しないで index.html に対するレスポンスを返し、 script.js を速やかにリクエストさせてキャッシュヒットさせたい。

問題はつまりこういうことです。

> ブラウザが何をキャッシュとして持っているか、サーバが知る方法が無い


ブラウザのキャッシュを取得できると、閲覧履歴などがわかってしまい問題となる可能性もあるため、基本的にこういうことはできません。


# cache aware server push

そこで、例えばサーバが script.js を Push をしたあとに、その事実を index.html の Cookie に付与しておけば、次のリクエストでは 「index.html が欲しいけど scirpt.js はもうキャッシュに有るから push しないでいいよ」という情報がとれます。

これによって、無駄な Push を減らそうというのが、 kazuho さんの考えた Cache Aware Server Push という方式です。

では、実際 cookie には何の情報を入れればいいでしょうか？


例えば、 script.js を Push したら "script.js" って書けばいいかもしれません。
しかし、それだとキャッシュされた script.js よりも、サーバが持っている script.js が新しく更新された場合に、「新しくなったから更新」ということができません。

そこで、ファイルのバージョンを示すのに使われる Etag の値を一緒に載せると良さそうです。

こんな感じでしょうか。

```
/assets/scripts/script.js:zidr965q3jalsfda4
```

でもこれ、ファイルパスや Etag が長くて、さらにファイルが何個もあったら、すぐに膨らんでしまいます。
Cookie は他にも多くの情報を入れるために使われるので、ちょっと辛いですね。

そこで、この情報をうまく圧縮することを考えます。


# false positive

ファイルパスと Etag があれば十分ではありますが、本質的に欲しい情報は何かと言うと

「今から Push しようとしているファイルは、すでにキャッシュに有るかどうか？」です。

ところで 100% わからないとダメでしょうか？
そもそも、ブラウザのキャッシュなんていつ消えるかわかりません。 Cookie がそれと完全に同期するのがそもそも無理です。

そして、もし当てが外れても以下の二通りです。

- 「キャッシュされてると思って Push しなかったら、されてなかった」=> ブラウザが普通に GET するだけ
- 「キャッシュされてないと思って Push したら、されてた」 => キャッシュが上書きされるだけ

実は Push は読みが外れても動かなくなるものではありません。しかしどっちにせよ無駄な処理は減らしたいです。
つまり狙い目は、「なるべく無駄な Push を減らす」ことであり、そうすると本当に欲しい情報はこうです。


「今から Push しようとしているファイルは、すでにキャッシュに *有りそうかどうか?*」


100% でなくてもよい(あると思ったら無かった=false positive が許される)、となると実は情報を圧縮する方法がいくつかあります。
その代表例が確率的データ構造である bloom fileter です。


# bloom filter

bloom filter については [こちら](http://dev.ariel-networks.com/column/tech/boom_filter/) 説明あたりがわかりやすいと思います。

簡単に言えば、その構造体の中に特定のデータが含まれているかどうかを検査を、元のデータセットより小さいサイズで実現できます。

具体的には k 個のハッシュ関数を用意し、要素をそのハッシュにかけます。
そこ結果を、求めるデータサイズ m ビットで丸めると、 0~m の範囲の値が一要素につき k 個得られます。
ゼロクリアした m bit の値に対し、それぞれの値の場所(3 なら 3bit 目)を 1 にします。
全ての要素でこれを繰り返せば完成です。


ある要素がそこに入ってるかを検証するには、同じくハッシュを通してビットが立ってるかを調べます。

この場合、全部のビットが立ってなければ確実に無いことがわかります。
しかし、全部のビットが立っていても、それが他の要素の計算による可能性があるわけです。
これが "False Positive" = 「Positive(ある) と思ったら False(嘘) だった」です。


Bloom Filter は

- 要素数(ファイルの数) = n
- ハッシュ関数の数(要素ごとに立つビットの数) = k
- 結果のビット数 = m

とすると

```
誤検出の確率 = (1 - e*p(-float(k * n) / m)) ** k
m = -n*ln(p) / (ln(2)^2)
k = m/n * ln(2)
```

の関係がわかっています。
HTTP のペイロードに載せることを考えれば、計算量よりもデータサイズが小さいことが望ましいため、許容できる誤検出を元に、これを最適化することができます。

ただし、計算量を追加することで、より論理的な限界までこれを圧縮するというのが Golomb Coded Set(GCS) です。


## Golomb Coded Set(GCS)

Golomb-coded set  は、ほぼ [ここ](http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters) に書かれた通りなのでそれを元に紹介。


まずターゲットが以下の値(N=26)だとする。

```
['alpha', 'bravo', 'charlie', 'delta', 'echo', 'foxtrot',
 'golf', 'hotel', 'india', 'juliet', 'kilo', 'lima', 'mike',
 'november', 'oscar', 'papa', 'quebec', 'romeo', 'sierra',
 'tango', 'uniform', 'victor', 'whiskey', 'xray', 'yankee',
 'zulu']
```

これを P=64 (誤検出が64回に1回) になるようにする。

ハッシュ関数は、セキュリティ面で言われる危殆化が関係ないため、 MD5 や SHA1 などで構わない。
求めた値が `[0, N*P)` = `[0, 1664)`  に収まるように mod で丸め込む。

```
[('alpha', 1017), ('bravo', 591), ('charlie', 1207)...]
```


このハッシュ部分だけをソートする。


```
[151, 192, 208, ..., 1630]
```

ハッシュの質が良ければ、結果は `[0, 1664)` に一様分布するはず。

そして、それぞれの値の間の距離をとると以下になる。

```
[151, 41, 16, 61, ...]
```

26 個の値を `26*64` の間に分布させたので、距離の平均は 64 になるはず。
(実際計算してもなる)

すると、この配列の中には、多くの 64 近い値と、少しの 64 と遠い値があるはずである。
(実際、 64 との差の絶対値をプロットするとわかる)


Golomb Coded Set は、この性質を利用して、配列を圧縮する。

まず、この配列の各値を 64 で割る。多くの商は 0, 1, 2 あたりになる。(最悪 25 だがそれはハッシュ関数を見直した方が良い)

で、その商を Unary Encoding する。
具体的には、こう。

```
商   Unary encoding
 0   0
 1   10
 2   110
 3   1110
 4   11110
 5   111110
 6   1111110
```

商の数だけ 0 の前に 1 をつける。


これに余り(0~63) をそのまま 6bit バイナリとして加える。


  0~63  は   0+6bit で 7bit
 64~127 は  10+6bit で 8bit
128~191 は 110+6bit で 9bit

64 に近い値が多いという前提であれば、これで多くの値が小さくエンコードできることがわかるはずである。
これが基本的なアイデア。


[翻訳](http://qiita.com/Jxck_/private/aae8afc5ec9ee7518197)




# cache fingerprinting

cache fingerprinting とは、 server が投機的な push をすべきかどうかを知るために仕様することができます。

http2 の push はサーバが投機的に行うが、クライアントがすでにそのリソースをキャッシュしているかを知る方法はない。
この仕様は、 HTTP ヘッダにその情報を含むことでより効率的に push することを目的とする。


# Cache-Fingerprint-Key ヘッダ

"Cache-Fingerprint-Key" は fingerprint key を表す decimal number を値とする。

```
Cache-Fingerprint-Key: 12345
```

# Cache-Fingerprint Header Field

user agent はキャッシュしたレスポンスの fingerprint key を集め、Cache-Fingerprint ヘッダで送る。

user agent は fingerprint がキャッシュされて無くてもこのヘッダをかならず送る。

user agent が "Cache-Fingerprint" ヘッダを送った場合、 value は以下の用に処理される。

1. キャッシュされたレスポンスから "Cache-Fingerprint-Key" を集め、
2. なかったら 9 へ
3. key を代数ソートする
4. Golomb-Rice coding でパラメータを導出する。値は 2 の累乗で 1~2147483648 の範囲。
5. 4 の結果の log2 を 5-bit 値で導出
6. 4 の結果のキーを Golomb-Rice coding でエンコード
7. 結果が 1 つなら 9 へ
8. 最初のキー以外のキーを、一つ前のキーから

